"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageImpl = void 0;
const fs = require("fs");
const path = require("path");
/**
 * A {@link Storage} implementation that stores data in-memory and in a JSON file.
 */
class StorageImpl {
    constructor() {
        this.fullStoragePath = '';
        this.wasInitialized = false;
        this.entities = [];
    }
    init(entityName, storagePath) {
        return __awaiter(this, void 0, void 0, function* () {
            this.entityName = entityName;
            this.wasInitialized = true;
            this.fullStoragePath = this.generateStoragePathForEntity(entityName, storagePath);
            yield this.ensureStorageIsSetUp();
            yield this.loadAllFromStorage();
        });
    }
    generateStoragePathForEntity(entityName, storagePath) {
        return `${storagePath}/${entityName}.json`;
    }
    ensureStorageIsSetUp() {
        if (!fs.existsSync(this.fullStoragePath)) {
            this.createStorageDirectory();
            this.createStorageFile();
        }
    }
    createStorageDirectory() {
        const storagePathParts = path.parse(path.resolve(this.fullStoragePath));
        const storageDirectoryPath = path.join(storagePathParts.dir);
        if (!fs.existsSync(storageDirectoryPath)) {
            fs.mkdirSync(storageDirectoryPath, { recursive: true });
        }
    }
    createStorageFile() {
        try {
            fs.writeFileSync(this.fullStoragePath, JSON.stringify([]));
        }
        catch (err) {
            console.error('Error creating storage file:');
            console.error(err);
        }
    }
    loadAllFromStorage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.wasInitialized) {
                throw new Error('Trying to call getAll() without calling init() before');
            }
            try {
                const fileContents = yield new Promise((resolve, reject) => {
                    fs.readFile(this.fullStoragePath, (err, content) => {
                        if (err) {
                            return reject();
                        }
                        resolve(content);
                    });
                });
                this.entities = JSON.parse(fileContents.toString());
            }
            catch (err) {
                console.error('Error reading or parsing entities from ' + this.fullStoragePath + ' : ' + (err ? err.message : ''));
            }
        });
    }
    storeAllToStorage() {
        return new Promise((resolve, reject) => {
            fs.writeFile(this.fullStoragePath, JSON.stringify(this.entities, null, 2), (err) => {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    }
    create(entity) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((entity.id && (yield this.exists(entity.id))) || !entity.id) {
                entity.id = this.createNextEntityId();
            }
            this.entities.push(entity);
            yield this.storeAllToStorage();
            return entity;
        });
    }
    update(entity) {
        return __awaiter(this, void 0, void 0, function* () {
            if (entity.id == null) {
                throw new Error('Trying to update an entity without an ID');
            }
            const currentIndex = this.entities.findIndex(e => e.id === entity.id);
            this.entities[currentIndex] = entity;
            yield this.storeAllToStorage();
            return entity;
        });
    }
    createNextEntityId() {
        if (this.entities.length === 0) {
            return 0;
        }
        const sortedEntities = this.entities.sort((e1, e2) => `${e1.id}`.localeCompare(`${e2.id}`));
        const entityWithHighestId = sortedEntities[sortedEntities.length - 1];
        return entityWithHighestId.id + 1;
    }
    get(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.entities.find(e => e.id === id);
        });
    }
    getAll() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.entities;
        });
    }
    delete(entity) {
        return __awaiter(this, void 0, void 0, function* () {
            if (entity.id == null) {
                throw new Error('Trying to delete an entity without an ID');
            }
            const currentIndex = this.entities.findIndex(e => e.id === entity.id);
            if (currentIndex === -1) {
                throw new Error('Trying to delete entity that didn\'t exist');
            }
            this.entities.splice(currentIndex, 1);
            yield this.storeAllToStorage();
        });
    }
    exists(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const entity = yield this.get(id);
            return !!entity;
        });
    }
}
exports.StorageImpl = StorageImpl;
//# sourceMappingURL=StorageImpl.js.map